<!-- TOC -->

- [1. 进程相关结构体：_EPROCESS](#1-进程相关结构体_eprocess)
    - [1.1. +0x000 Pcb（type _KPROCESS）：线程调度相关](#11-0x000-pcbtype-_kprocess线程调度相关)
    - [1.2. _EPROCESS的其它重要成员](#12-_eprocess的其它重要成员)
- [2. 线程相关结构体：_ETHREAD](#2-线程相关结构体_ethread)
    - [2.1. +0x000 Tcb（type _KTHREAD）](#21-0x000-tcbtype-_kthread)
    - [2.2. _ETHREAD的其它重要成员](#22-_ethread的其它重要成员)
- [3. CPU相关结构体：_KPCR](#3-cpu相关结构体_kpcr)
    - [3.1. +0x000 NtTib（type _NT_TIB）](#31-0x000-nttibtype-_nt_tib)
    - [3.2. _KPCR的其它重要成员](#32-_kpcr的其它重要成员)
    - [3.3. +0x120 PrcbData（type _KPRCB）](#33-0x120-prcbdatatype-_kprcb)
- [4. 等待链表和调度链表](#4-等待链表和调度链表)
    - [4.1. 个链表：1个等待链表，32个调度链表](#41-个链表1个等待链表32个调度链表)
    - [4.2. 等待链表](#42-等待链表)
        - [4.2.1. 等待链表头](#421-等待链表头)
    - [4.3. 调度链表](#43-调度链表)
        - [4.3.1. 调度链表头](#431-调度链表头)
    - [4.4. 版本差异](#44-版本差异)
- [5. 线程切换](#5-线程切换)
    - [5.1. 线程切换原理](#51-线程切换原理)
        - [5.1.1. 模拟代码](#511-模拟代码)
        - [5.1.2. 线程切换的本质](#512-线程切换的本质)
    - [5.2. 线程切换的时机](#52-线程切换的时机)
        - [5.2.1. 当前线程调用API时的线程切换](#521-当前线程调用api时的线程切换)
        - [5.2.2. 时钟中断时的两种线程切换](#522-时钟中断时的两种线程切换)
            - [5.2.2.1. CPU时间片到期切换](#5221-cpu时间片到期切换)
            - [5.2.2.2. 备用线程切换](#5222-备用线程切换)
        - [5.2.3. 如何一直占据CPU](#523-如何一直占据cpu)
    - [5.3. 线程切换时做了什么](#53-线程切换时做了什么)
        - [5.3.1. 线程的内核堆栈](#531-线程的内核堆栈)
        - [5.3.2. 填充TSS](#532-填充tss)
        - [5.3.3. 修改FS段描述符](#533-修改fs段描述符)
    - [5.4. 找到要运行的线程：调度算法](#54-找到要运行的线程调度算法)
        - [5.4.1. _KiReadySummary](#541-_kireadysummary)
        - [5.4.2. 多核调度](#542-多核调度)
        - [5.4.3. 如果没有就绪线程怎么办：空闲线程](#543-如果没有就绪线程怎么办空闲线程)
- [6. 进程与进程挂靠](#6-进程与进程挂靠)
    - [6.1. 进程与线程的关系](#61-进程与线程的关系)
    - [6.2. _KTHREAD.ApcState.Process和_ETHREAD.ThreadsProcess](#62-_kthreadapcstateprocess和_ethreadthreadsprocess)
    - [6.3. 进程切换的本质](#63-进程切换的本质)
    - [6.4. 进程挂靠](#64-进程挂靠)
    - [6.5. 进程挂靠的步骤](#65-进程挂靠的步骤)
    - [6.6. 跨进程读写内存的步骤](#66-跨进程读写内存的步骤)

<!-- /TOC -->
# 1. 进程相关结构体：_EPROCESS
每个Windows进程在0环都有一个对应的结构体_EPROCESS，这个结构体包含了进程所有重要的信息
## 1.1. +0x000 Pcb（type _KPROCESS）：线程调度相关
* `+0x000 Header           : _DISPATCHER_HEADER`：标识_KPROCESS即进程为可等待对象（即可被WaitForSingleObject等函数等待的对象，如Mutex互斥体、Event事件等），所有可等待对象的第一个成员均为_DISPATCHER_HEADER结构体
* `+0x018 DirectoryTableBase : [2] Uint4B`：页目录表的基址
* `+0x020 LdtDescriptor    : _KGDTENTRY`：历史遗留问题，16位Windows段选择子不够，所以每个进程都有一个LDT表；32位Windows下该成员无意义
* `+0x028 Int21Descriptor  : _KIDTENTRY`：DOS下使用
* `+0x038 KernelTime       : Uint4B`：统计信息，统计进程在内核模式下所花的时间
* `+0x03c UserTime         : Uint4B`：统计信息，统计进程在用户模式下所花的时间
* `+0x050 ThreadListHead   : _LIST_ENTRY`：连接该进程所有线程的双向链表（总共存在两个这样的链表）的头，示意图见2.1节
* `+0x05c Affinity         : Uint4B`：规定进程里面的所有线程能够在哪个CPU上运行，比特位为1的下标号对应的CPU可以运行，比如4（100）代表可以在2号CPU上运行，如果此时只有一个或者两个CPU，该进程将会结束。所以32位最多32核，64位最多64核
* `+0x062 BasePriority     : Char`：基础优先级，该进程中所有线程最起码的优先级（即所有线程的优先级均会大于等于此优先级）
* `+0x063 ThreadQuantum    : Char`：调度相关，线程CPU时间片基础值
## 1.2. _EPROCESS的其它重要成员
* `+0x070 CreateTime       : _LARGE_INTEGER`：进程的创建时间
* `+0x078 ExitTime         : _LARGE_INTEGER`：进程的退出时间
* `+0x084 UniqueProcessId  : Ptr32 Void`：进程的编号即PID
* `+0x088 ActiveProcessLinks : _LIST_ENTRY`：连接所有活动进程的双向链表，全局变量PsActiveProcessHead指向链表头。利用PsActiveProcessHead加上该成员可以遍历所有进程，通过断链可以使得可以从WindowsAPI中隐藏进程，但是进程仍然可以正常运行（Windows的调度单元是线程，进程仅仅提供了一个运行环境如资源和物理页基址）
    * ![ActiveProcessLinks](../photo/操作系统_进程与线程_ActiveProcessLinks.jpg)
* `+0x090 QuotaUsage       : [3] Uint4B`：物理页相关统计信息
* `+0x09c QuotaPeak        : [3] Uint4B`：物理页相关统计信息
* `+0x0a8 CommitCharge     : Uint4B`：虚拟内存（物理页面以文件形式存储在硬盘中）相关统计信息
* `+0x0ac PeakVirtualSize  : Uint4B`：虚拟内存相关统计信息
* `+0x0b0 VirtualSize      : Uint4B`：虚拟内存相关统计信息
* `+0x0bc DebugPort        : Ptr32 Void`：调试端口，调试相关，该值为0的情况下无法通过正常手段来调试进程（可以通过其它手段）
* `+0x0c0 ExceptionPort    : Ptr32 Void`：异常端口，调试相关
* `+0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE`：句柄表，存有进程使用的各种其它内核的对象（事件、互斥体、文件等）的句柄（即地址）
* `+0x11c VadRoot          : Ptr32 Void`：标识用户地址空间使用情况
* `+0x174 ImageFileName    : [16] UChar`：进程镜像文件名，最多显示16个字节，多余字节将被截断
* `+0x190 ThreadListHead   : _LIST_ENTRY`：连接该进程所有线程的双向链表（总共存在两个这样的链表）的头，示意图见2.1节
* `+0x1a0 ActiveThreads    : Uint4B`：活动线程的数量，0代表无活动线程，进程即将结束，将会从活动进程链表中被移除
* `+0x1b0 Peb              : Ptr32 _PEB`：Process Environment Block，进程环境块，进程在3环的一个结构体（3环进程可以对其进行读写），里面包含了进程的模块列表、是否处于调试状态等重要信息
# 2. 线程相关结构体：_ETHREAD
每个Windows线程在0环都有一个对应的结构体_ETHREAD，这个结构体包含了线程所有重要的信息
## 2.1. +0x000 Tcb（type _KTHREAD）
* `+0x000 Header           : _DISPATCHER_HEADER`：标识_KTHREAD即线程为可等待对象
* `+0x018 InitialStack     : Ptr32 Void`：线程切换相关
* `+0x01c StackLimit       : Ptr32 Void`：线程切换相关
* `+0x020 Teb              : Ptr32 Void`：Thread Environment Block，线程环境块，大小4KB，线程在3环的一个结构体（3环进程可以对其进行读写），里面包含了线程的重要信息，在三环时fs:[0] -> teb，在0环时fs:[0] -> _kpcr
* `+0x028 KernelStack      : Ptr32 Void`：线程切换时存储栈顶指针
* `+0x02c DebugActive      : UChar`：调试相关，该值为-1的话不能使用调试寄存器Dr0-Dr7，3环进入0环时不会填充_kTrap_Frame中调试相关成员的值
* `+0x02d State            : UChar`：线程状态：就绪、等待、运行，仅仅用作记录，和线程的调度无关
* `+0x034 ApcState         : _KAPC_STATE`：APC相关
* `+0x060 WaitListEntry    : _LIST_ENTRY`：线程所属等待链表，线程调度相关
* `+0x060 SwapListEntry    : _SINGLE_LIST_ENTRY`：线程所属调度链表，线程调度相关，和线程所属等待链表占据同一个位置，也就是说线程只能同时属于其中一个链表
* `+0x06c BasePriority     : Char`：基础优先级，从所属进程继承而来（KPROCESS->BasePriority），但是可以通过KeSetBasePriorityThread函数重新设置
* `+0x06f Quantum          : Char`：调度相关，CPU时间片
* `+0x070 WaitBlock        : [4] _KWAIT_BLOCK`：指示线程等待的是哪个对象
* `+0x0e0 ServiceTable     : Ptr32 Void`：系统服务表基址
* `+0x0e8 ApcQueueLock     : Uint4B`：APC相关
* `+0x134 TrapFrame        : Ptr32 _KTRAP_FRAME`：用于进0环时保存环境
* `+0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE`：APC相关
* `+0x140 PreviousMode     : Char`：先前模式，用于某些内核函数判断程序是0环调用的还是3环调用的
* `+0x14c SavedApcState    : _KAPC_STATE`：APC相关
+0x06f Quantum          : Char
* `+0x1b0 ThreadListEntry  : _LIST_ENTRY`：连接一个进程所有线程的双向链表，总共存在两个这样的链表
    * ![ThreadListEntry](../photo/操作系统_进程与线程_ThreadListEntry.jpg)
## 2.2. _ETHREAD的其它重要成员
* `+0x1ec Cid              : _CLIENT_ID`：进程ID和线程ID
* `+0x220 ThreadsProcess   : Ptr32 _EPROCESS`：当前进程结构体的指针，可以定位进程
* `+0x22c ThreadListEntry  : _LIST_ENTRY`：连接一个进程所有线程的双向链表，总共存在两个这样的链表
# 3. CPU相关结构体：_KPCR
每个CPU在0环都有一个对应的结构体_KPCR，这个结构体包含了CPU本身要用的一些重要数据如GDT、IDT、线程相关信息
## 3.1. +0x000 NtTib（type _NT_TIB）
* `+0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD`：当前线程内核异常链表（SEH）
* `+0x004 StackBase        : Ptr32 Void`：当前线程内核栈基址
* `+0x008 StackLimit       : Ptr32 Void`：当前线程内核栈大小
* `+0x018 Self             : Ptr32 _NT_TIB`：指向自身（_NT_TIB和_KPCR）
## 3.2. _KPCR的其它重要成员
* `+0x01c SelfPcr          : Ptr32 _KPCR`：指向自身（_KPCR）
* `+0x020 Prcb             : Ptr32 _KPRCB`：指针，指向_KPCR的PrcbData成员，方便日后修改拓展_KPCR结构体
* `+0x038 IDT              : Ptr32 _KIDTENTRY`：IDT表基址，每个CPU都有自己独立的IDT表
* `+0x03c GDT              : Ptr32 _KGDTENTRY`：GDT表基址，每个CPU都有自己独立的GDT表
* `+0x040 TSS              : Ptr32 _KTSS`：TSS任务段基址，每个CPU都有自己独立的TSS任务段
* `+0x051 Number           : UChar`：当前CPU编号
* `+0x120 PrcbData         : _KPRCB`：_KPCR的拓展结构体
## 3.3. +0x120 PrcbData（type _KPRCB）
* `+0x004 CurrentThread    : Ptr32 _KTHREAD`：CPU当前正在运行的线程
* `+0x008 NextThread       : Ptr32 _KTHREAD`：CPU下一个调度的线程
* `+0x00c IdleThread       : Ptr32 _KTHREAD`：空闲线程，如果没有其它线程可以调度时，CPU需要调度的线程
* `+0x88c QuantumEnd       : Uint4B`：标志当前线程的CPU时间片是否用完，没用完的时候是0，用完的时候是非0值
# 4. 等待链表和调度链表
## 4.1. 个链表：1个等待链表，32个调度链表
线程有三种状态：等待、就绪、运行。正在运行的线程存储在_KPCR中，就绪和等待线程则存储在另外的33个链表中，1个等待链表，32个就绪链表。这些链表都使用了_KTHREAD的0x060这个偏移，所以一个线程只能同时属于其中一个链表
## 4.2. 等待链表
所有等待状态的线程都存储在这个链表里面，比如说线程调用了Sleep或者WaitForSingleObject等函数时，就挂到这个链表里面
### 4.2.1. 等待链表头
Windbg命令`dd KiWaitListHead`可以查看等待链表头
## 4.3. 调度链表
总共有32个调度链表，分别对应线程优先级0-31，0最低，31最高，默认优先级一般是8，改变优先级就是脱链再挂链的过程。所有处于就绪状态的线程都存储在这些链表里面
### 4.3.1. 调度链表头
Windbg命令`dd KiDispatcherReadyListHead L70`可以查看调度链表头的数组，每个成员长度为8个字节，优先级依次为0-31
## 4.4. 版本差异
* WinXP中，无论有几个CPU，等待链表和调度链表只有一套，也就是1个等待链表+32个调度链表
* Win7中，无论有几个CPU，等待链表和调度链表只有一套，也就是1个等待链表+32个调度链表（64位中是64个调度链表）
* 服务器版本（比如Win2003）中，等待链表整个系统只有一套，但是调度链表是有几个CPU就有几套调度链表
# 5. 线程切换
## 5.1. 线程切换原理
### 5.1.1. 模拟代码
```c
#include "stdio.h"
#include <windows.h>

#define GMTHREADSTACKSIZE 0x80000     //定义线程栈的大小
#define MAXGMTHREAD 100   //支持的最大线程数

//线程信息结构体
typedef struct
{
	char* name;						//线程名
	int Flags;						//线程状态
	int SleepMillsecondDot;			//休眠时间

	void* initialStack;				//线程堆栈起始位置
	void* StackLimit;				//线程堆栈界限
	void* KernelStack;				//线程堆栈当前位置，也就是ESP

	void* lpParameter;				//线程函数的参数
	void(*func)(void* lpParameter);	//线程函数
}GMThread_t;

GMThread_t GMThreadList[MAXGMTHREAD] = { NULL, 0 };   //线程的列表
int CurrentThreadIndex = 0;  //当前线程的索引

//线程状态的标志
enum FLAGS
{
	GMTHREAD_CREATE = 0x1,
	GMTHREAD_READY = 0x2,
	GMTHREAD_SLEEP = 0x4,
	GMTHREAD_EXIT = 0x8,
};

//真正实现线程切换的函数
__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp)
{
	__asm {
		//提升堆栈
		push ebp
			mov ebp, esp
			//保存现场
			push edi
			push esi
			push ebx
			push ecx
			push edx
			push eax
			//esi、edi指向
			mov esi, SrcGMThreadp
			mov edi, DstGMThreadp
			mov[esi + GMThread_t.KernelStack], esp;   把esp保存到kernelstack
			//经典线程切换，另外一个线程复活
			mov esp, [edi + GMThread_t.KernelStack]; 修改esp为目标线程的kernelstack

			pop eax
			pop edx
			pop ecx
			pop ebx
			pop esi
			pop edi
			pop ebp
			ret
	}
}

//调度
void Scheduling(void)
{
	int i;
	int TickCount;
	GMThread_t* SrcGMThreadp;
	GMThread_t* DstGMThreadp;
	TickCount = GetTickCount();     //获取当前tickcount
	SrcGMThreadp = &GMThreadList[CurrentThreadIndex];     //当前线程
	DstGMThreadp = &GMThreadList[0];    //目标线程暂时指向0

	for (i = 1; GMThreadList[i].name; i++) {     //遍历线程
		if (GMThreadList[i].Flags & GMTHREAD_SLEEP) {     //如果是休眠状态的线程
			if (TickCount > GMThreadList[i].SleepMillsecondDot) {       //如果当前tickcount大于唤醒时间，修改状态为就绪
				GMThreadList[i].Flags = GMTHREAD_READY;
			}
		}
		if (GMThreadList[i].Flags & GMTHREAD_READY) {      //如果是就绪状态的线程
			DstGMThreadp = &GMThreadList[i];        //修改目标线程指向就绪状态
			break;
		}
	}

	CurrentThreadIndex = DstGMThreadp - GMThreadList;    //获取目标线程索引（当前-0）
	SwitchContext(SrcGMThreadp, DstGMThreadp);      //切换线程
	return;
}

//启动线程的函数
void GMThreadStartup(GMThread_t* GMThreadp)
{
	GMThreadp->func(GMThreadp->lpParameter);    //调用线程函数，阻塞
	GMThreadp->Flags = GMTHREAD_EXIT;           //标志位修改为退出
	Scheduling();

	return;
}

//空闲线程的函数
void IdleGMThread(void* lpParameter)
{
	printf("IdleGMThread---------------\n");
	Scheduling();
	return;
}

//模拟压栈操作
void PushStack(unsigned int** Stackpp, unsigned int v)
{
	*Stackpp -= 1;
	**Stackpp = v;

	return;
}

//初始化线程
void initGMThread(GMThread_t* GMThreadp, char* name, void(*func)(void* lpParameter), void* lpParameter)
{
	unsigned char* StackPages;
	unsigned int* StackDWordParam;
	GMThreadp->Flags = GMTHREAD_CREATE;    //创建状态
	GMThreadp->name = name;
	GMThreadp->func = func;
	GMThreadp->lpParameter = lpParameter;
	StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE);   //申请一片栈空间
	ZeroMemory(StackPages, GMTHREADSTACKSIZE);    //初始化栈空间为0
	GMThreadp->initialStack = StackPages + GMTHREADSTACKSIZE;     //获取栈的初始位置
	StackDWordParam = (unsigned int*)GMThreadp->initialStack;     //获取栈指针
	//入栈
	PushStack(&StackDWordParam, (unsigned int)GMThreadp);         //压入结构体指针，充当启动线程的函数GMThreadStartup函数的参数
	PushStack(&StackDWordParam, (unsigned int)0);                 //压入0，充当启动线程的函数GMThreadStartup函数的返回地址
	PushStack(&StackDWordParam, (unsigned int)GMThreadStartup);   //压入启动线程的函数
	PushStack(&StackDWordParam, (unsigned int)5);                 //压入其它寄存器
	PushStack(&StackDWordParam, (unsigned int)7);
	PushStack(&StackDWordParam, (unsigned int)6);
	PushStack(&StackDWordParam, (unsigned int)3);
	PushStack(&StackDWordParam, (unsigned int)2);
	PushStack(&StackDWordParam, (unsigned int)1);
	PushStack(&StackDWordParam, (unsigned int)0);
	//当前线程的栈顶
	GMThreadp->KernelStack = StackDWordParam;
	GMThreadp->Flags = GMTHREAD_READY;          //就绪状态
	return;
}

//注册线程
int RegisterGMThread(char* name, void(*func)(void*lpParameter), void* lpParameter)
{
	int i;
	for (i = 1; GMThreadList[i].name; i++) {       //查找线程列表中是否有同名线程
		if (0 == _stricmp(GMThreadList[i].name, name)) {       //如果有同名线程，则定位到该线程，否则定位到下一个空位
			break;
		}
	}
	initGMThread(&GMThreadList[i], name, func, lpParameter);    //初始化线程

	return (i & 0x55AA0000);
}

//线程函数中调用的函数
void GMSleep(int MilliSeconds)
{
	GMThread_t* GMThreadp;
	GMThreadp = &GMThreadList[CurrentThreadIndex];    //获取当前线程结构体指针
	if (GMThreadp->Flags != 0) {         //处于正常状态
		GMThreadp->Flags = GMTHREAD_SLEEP;           //进入休眠状态
		GMThreadp->SleepMillsecondDot = GetTickCount() + MilliSeconds;      //设置唤醒时间
	}

	Scheduling();    //调度其它线程
	return;
}

void Thread1(void*) {
	while (1){
		printf("Thread11111111111111111111111111111111111111111111111111111\n");
		GMSleep(500);
	}
}
void Thread2(void*) {
	while (1) {
		printf("Thread2222222222222222222222222222222222\n");
		GMSleep(200);
	}
}

void Thread3(void*) {
	while (1) {
		printf("Thread3333333333333333333\n");
		GMSleep(10);
	}
}

void Thread4(void*) {
	while (1) {
		printf("Thread444\n");
		GMSleep(1000);
	}
}


int main()
{
	RegisterGMThread("Thread1", Thread1, NULL);
	RegisterGMThread("Thread2", Thread2, NULL);
	RegisterGMThread("Thread3", Thread3, NULL);
	RegisterGMThread("Thread4", Thread4, NULL);

	while (true) {
		Sleep(5);
		Scheduling();
	}

	return 0;
}
```
### 5.1.2. 线程切换的本质
线程切换的过程本质上就是堆栈切换的过程
## 5.2. 线程切换的时机
### 5.2.1. 当前线程调用API时的线程切换
Windows中的绝大多数API都会调用KiSwapThread->kiSwapContext->SwapContext函数导致线程切换，也就是说，只要调用Windows API，基本就会导致线程切换
### 5.2.2. 时钟中断时的两种线程切换
Windows系列操作系统的时钟中断时间间隔是10-20ms（可以通过函数GetSystemTimeAdjustment来查看）
#### 5.2.2.1. CPU时间片到期切换
当一个新的线程开始执行时，初始化程序会给_KTHREAD.Quantum赋初始值，该值的大小由_KPROCESS.ThreadQuantum决定。每次时钟中断的时候会调用KeUpdateRunTime函数将当前线程的Quantum值减3，如果减到0，则将KPCR.PrcbData.QuantumEnd的值设置为非0。时钟中断的最后，会调用KiDispatchInterrupt函数判断KPCR.PrcbData.QuantumEnd是否为0，如果是则调用KiQuantumEnd来重新设置时间片、找到要运行的线程，之后调用SwapContext来切换线程
#### 5.2.2.2. 备用线程切换
KiDispatchInterrupt函数中即使判断CPU时间片没有到期，如果之后判断当前线程存在备用线程（KPCR.PrcbData.NextThread值不为空），也会调用SwapContext来切换线程
### 5.2.3. 如何一直占据CPU
如果一个线程不调用API，在代码中屏蔽时钟中断（CLI指令或者popfd来设置IF位为0，只能在0环设置），并且确保不会出现异常，那么当前线程将永久占有该CPU。所以抢占式调度是一个错误的说法，线程只能是主动切换即线程主动让出CPU
## 5.3. 线程切换时做了什么
### 5.3.1. 线程的内核堆栈
每个线程都有一个内核堆栈，线程的内核堆栈通过_KTHREAD.InitialStack、_KTHREAD.KernelStack、_KTHREAD.StackLimit来界定。线程的内核堆栈从高地址开始，前0x210个字节存储的是浮点寄存器的值，之后是_Trap_Frame结构体。线程调用API进入0环时，中断门调用通过TSS.ESP0得到0环堆栈，快速调用通过MSR获取一个临时0环堆栈，之后仍然会通过TSS.ESP0获取真正的0环堆栈。
### 5.3.2. 填充TSS
* 切换线程后，会保存当前线程堆栈至TSS.esp0，用于之后线程进入内核的时候获取内核堆栈
* 获取新线程页目录表基址，填充到TSS，并切换至cr3寄存器
* 获取新线程IO权限位图（_KTHREAD.Iopl），填充到TSS->I/O Map Base Address
### 5.3.3. 修改FS段描述符
线程切换的时候，会修改FS段选择子对应的段描述符里面的基地址，从而实现无需修改FS段选择子，但是切换了TEB（切换了线程）
## 5.4. 找到要运行的线程：调度算法
Windows通过函数KiFindReadyThread来找到下一个应该运行的线程，查找方式为按照优先级别从高到低进行查找，找到就停止
### 5.4.1. _KiReadySummary
为了提高查找就绪线程的效率，Windows设计了一个32位变量_KiReadySummary，该变量每个比特位对应一个相应优先级的调度链表。当向某个调度链表中挂入或者摘除线程后，会判断调度链表是否为空（判断KiDispatcherReadyListHead中的双向链表，如果头指针和尾指针相同且等于当前地址，则为空，如果头指针和尾指针相同但是不等于当前地址，则调度链表中存在一个线程），如果是则置该变量对应比特位为0，不是则置1
### 5.4.2. 多核调度
多个CPU时，会随机寻找KiDispatcherReadyListHead指向的数组中的线程，线程可以绑定某个CPU（setThreadAffinityMask）
### 5.4.3. 如果没有就绪线程怎么办：空闲线程
当CPU发现没有就绪线程的时候，会调度空闲线程（_KPCR.PrcbData.IdleThread指向的线程）
# 6. 进程与进程挂靠
## 6.1. 进程与线程的关系
一个进程可以包含多个线程、一个进程至少含有一个线程。进程通过_KPROCESS.DirectoryTableBase为线程提供CR3的值，提供线程所能访问的内存空间
## 6.2. _KTHREAD.ApcState.Process和_ETHREAD.ThreadsProcess
* _ETHREAD.ThreadsProcess的值为创建线程的进程
* _KTHREAD.ApcState.Process指示哪个进程在为线程提供CR3的值，一般情况下，这个值和_ETHREAD.ThreadsProcess相同
## 6.3. 进程切换的本质
线程切换的时候，会比较新旧线程的_KTHREAD.ApcState.Process是否为同一个，如果不是同一个，会切换CR3为新线程所属进程的_KPROCESS.DirectoryTableBase，进程切换的本质就是切换CR3
## 6.4. 进程挂靠
切换CR3，从此该线程读写的均为其它进程的内存空间，称为进程挂靠。进程挂靠使得线程可以突破限制，访问别的进程的内存空间。NtReadVirtualMemory函数在读取其他进程的内存空间的时候，就是采取的进程挂靠的方式（KiAttachProcess函数实现进程挂靠）
## 6.5. 进程挂靠的步骤
* 修改_KTHREAD.ApcState.Process（这一步必须执行，不然一旦产生线程切换，由于在线程切换的时候会依据_KTHREAD.ApcState.Process来修改CR3，所以会出现错误，除非通过屏蔽中断+避免异常+不调用产生线程切换的API的形式来避免线程切换）
* 修改CR3的值
## 6.6. 跨进程读写内存的步骤
* 读内存
	* 切换CR3到目标进程（进程挂靠）
	* 读内存，并保存到高2G地址中的暂存区（高2G中该暂存区对两个进程来说映射相同，这样才能保证在切换CR3回到本进程的时候，实际地址不变，内容不变）
	* 切换CR3回到本进程
	* 将暂存区中的数据复制到缓冲区
* 写内存
	* 将缓冲区中的数据复制到高2G地址中的暂存区
	* 切换CR3到目标进程（进程挂靠）
	* 将暂存区中的数据写入内存
	* 切换CR3回到本进程