<!-- TOC -->

- [1. 进程相关结构体：_EPROCESS](#1-进程相关结构体_eprocess)
    - [1.1. +0x000 Pcb（type _KPROCESS）：线程调度相关](#11-0x000-pcbtype-_kprocess线程调度相关)
    - [1.2. _EPROCESS的其它重要成员](#12-_eprocess的其它重要成员)
- [2. 线程相关结构体：_ETHREAD](#2-线程相关结构体_ethread)
    - [2.1. +0x000 Tcb（type _KTHREAD）](#21-0x000-tcbtype-_kthread)
    - [2.2. _ETHREAD的其它重要成员](#22-_ethread的其它重要成员)
- [3. CPU相关结构体：_KPCR](#3-cpu相关结构体_kpcr)
    - [3.1. +0x000 NtTib（type _NT_TIB）](#31-0x000-nttibtype-_nt_tib)
    - [3.2. _KPCR的其它重要成员](#32-_kpcr的其它重要成员)
    - [3.3. +0x120 PrcbData（type _KPRCB）](#33-0x120-prcbdatatype-_kprcb)
- [4. 等待链表和调度链表](#4-等待链表和调度链表)
    - [4.1. 个链表：1个等待链表，32个调度链表](#41-个链表1个等待链表32个调度链表)
    - [4.2. 等待链表](#42-等待链表)
        - [4.2.1. 等待链表头](#421-等待链表头)
    - [4.3. 调度链表](#43-调度链表)
        - [4.3.1. 调度链表头](#431-调度链表头)
    - [4.4. 版本差异](#44-版本差异)
- [线程切换](#线程切换)

<!-- /TOC -->
# 1. 进程相关结构体：_EPROCESS
每个Windows进程在0环都有一个对应的结构体_EPROCESS，这个结构体包含了进程所有重要的信息
## 1.1. +0x000 Pcb（type _KPROCESS）：线程调度相关
* `+0x000 Header           : _DISPATCHER_HEADER`：标识_KPROCESS即进程为可等待对象（即可被WaitForSingleObject等函数等待的对象，如Mutex互斥体、Event事件等），所有可等待对象的第一个成员均为_DISPATCHER_HEADER结构体
* `+0x018 DirectoryTableBase : [2] Uint4B`：页目录表的基址
* `+0x020 LdtDescriptor    : _KGDTENTRY`：历史遗留问题，16位Windows段选择子不够，所以每个进程都有一个LDT表；32位Windows下该成员无意义
* `+0x028 Int21Descriptor  : _KIDTENTRY`：DOS下使用
* `+0x038 KernelTime       : Uint4B`：统计信息，统计进程在内核模式下所花的时间
* `+0x03c UserTime         : Uint4B`：统计信息，统计进程在用户模式下所花的时间
* `+0x050 ThreadListHead   : _LIST_ENTRY`：连接该进程所有线程的双向链表（总共存在两个这样的链表）的头，示意图见2.1节
* `+0x05c Affinity         : Uint4B`：规定进程里面的所有线程能够在哪个CPU上运行，比特位为1的下标号对应的CPU可以运行，比如4（100）代表可以在2号CPU上运行，如果此时只有一个或者两个CPU，该进程将会结束。所以32位最多32核，64位最多64核
* `+0x062 BasePriority     : Char`：基础优先级，该进程中所有线程最起码的优先级（即所有线程的优先级均会大于等于此优先级）
## 1.2. _EPROCESS的其它重要成员
* `+0x070 CreateTime       : _LARGE_INTEGER`：进程的创建时间
* `+0x078 ExitTime         : _LARGE_INTEGER`：进程的退出时间
* `+0x084 UniqueProcessId  : Ptr32 Void`：进程的编号即PID
* `+0x088 ActiveProcessLinks : _LIST_ENTRY`：连接所有活动进程的双向链表，全局变量PsActiveProcessHead指向链表头。利用PsActiveProcessHead加上该成员可以遍历所有进程，通过断链可以使得可以从WindowsAPI中隐藏进程，但是进程仍然可以正常运行（Windows的调度单元是线程，进程仅仅提供了一个运行环境如资源和物理页基址）
    * ![ActiveProcessLinks](../photo/操作系统_进程与线程_ActiveProcessLinks.jpg)
* `+0x090 QuotaUsage       : [3] Uint4B`：物理页相关统计信息
* `+0x09c QuotaPeak        : [3] Uint4B`：物理页相关统计信息
* `+0x0a8 CommitCharge     : Uint4B`：虚拟内存（物理页面以文件形式存储在硬盘中）相关统计信息
* `+0x0ac PeakVirtualSize  : Uint4B`：虚拟内存相关统计信息
* `+0x0b0 VirtualSize      : Uint4B`：虚拟内存相关统计信息
* `+0x0bc DebugPort        : Ptr32 Void`：调试端口，调试相关，该值为0的情况下无法通过正常手段来调试进程（可以通过其它手段）
* `+0x0c0 ExceptionPort    : Ptr32 Void`：异常端口，调试相关
* `+0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE`：句柄表，存有进程使用的各种其它内核的对象（事件、互斥体、文件等）的句柄（即地址）
* `+0x11c VadRoot          : Ptr32 Void`：标识用户地址空间使用情况
* `+0x174 ImageFileName    : [16] UChar`：进程镜像文件名，最多显示16个字节，多余字节将被截断
* `+0x190 ThreadListHead   : _LIST_ENTRY`：连接该进程所有线程的双向链表（总共存在两个这样的链表）的头，示意图见2.1节
* `+0x1a0 ActiveThreads    : Uint4B`：活动线程的数量，0代表无活动线程，进程即将结束，将会从活动进程链表中被移除
* `+0x1b0 Peb              : Ptr32 _PEB`：Process Environment Block，进程环境块，进程在3环的一个结构体（3环进程可以对其进行读写），里面包含了进程的模块列表、是否处于调试状态等重要信息
# 2. 线程相关结构体：_ETHREAD
每个Windows线程在0环都有一个对应的结构体_ETHREAD，这个结构体包含了线程所有重要的信息
## 2.1. +0x000 Tcb（type _KTHREAD）
* `+0x000 Header           : _DISPATCHER_HEADER`：标识_KTHREAD即线程为可等待对象
* `+0x018 InitialStack     : Ptr32 Void`：线程切换相关
* `+0x01c StackLimit       : Ptr32 Void`：线程切换相关
* `+0x020 Teb              : Ptr32 Void`：Thread Environment Block，线程环境块，大小4KB，线程在3环的一个结构体（3环进程可以对其进行读写），里面包含了线程的重要信息，在三环时fs:[0] -> teb，在0环时fs:[0] -> _kpcr
* `+0x028 KernelStack      : Ptr32 Void`：线程切换相关
* `+0x02c DebugActive      : UChar`：调试相关，该值为-1的话不能使用调试寄存器Dr0-Dr7，3环进入0环时不会填充_kTrap_Frame中调试相关成员的值
* `+0x02d State            : UChar`：线程状态：就绪、等待、运行，仅仅用作记录，和线程的调度无关
* `+0x034 ApcState         : _KAPC_STATE`：APC相关
* `+0x060 WaitListEntry    : _LIST_ENTRY`：线程所属等待链表，线程调度相关
* `+0x060 SwapListEntry    : _SINGLE_LIST_ENTRY`：线程所属调度链表，线程调度相关，和线程所属等待链表占据同一个位置，也就是说线程只能同时属于其中一个链表
* `+0x06c BasePriority     : Char`：基础优先级，从所属进程继承而来（KPROCESS->BasePriority），但是可以通过KeSetBasePriorityThread函数重新设置
* `+0x070 WaitBlock        : [4] _KWAIT_BLOCK`：指示线程等待的是哪个对象
* `+0x0e0 ServiceTable     : Ptr32 Void`：系统服务表基址
* `+0x0e8 ApcQueueLock     : Uint4B`：APC相关
* `+0x134 TrapFrame        : Ptr32 _KTRAP_FRAME`：用于进0环时保存环境
* `+0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE`：APC相关
* `+0x140 PreviousMode     : Char`：先前模式，用于某些内核函数判断程序是0环调用的还是3环调用的
* `+0x14c SavedApcState    : _KAPC_STATE`：APC相关
* `+0x1b0 ThreadListEntry  : _LIST_ENTRY`：连接一个进程所有线程的双向链表，总共存在两个这样的链表
    * ![ThreadListEntry](../photo/操作系统_进程与线程_ThreadListEntry.jpg)
## 2.2. _ETHREAD的其它重要成员
* `+0x1ec Cid              : _CLIENT_ID`：进程ID和线程ID
* `+0x220 ThreadsProcess   : Ptr32 _EPROCESS`：当前进程结构体的指针，可以定位进程
* `+0x22c ThreadListEntry  : _LIST_ENTRY`：连接一个进程所有线程的双向链表，总共存在两个这样的链表
# 3. CPU相关结构体：_KPCR
每个CPU在0环都有一个对应的结构体_KPCR，这个结构体包含了CPU本身要用的一些重要数据如GDT、IDT、线程相关信息
## 3.1. +0x000 NtTib（type _NT_TIB）
* `+0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD`：当前线程内核异常链表（SEH）
* `+0x004 StackBase        : Ptr32 Void`：当前线程内核栈基址
* `+0x008 StackLimit       : Ptr32 Void`：当前线程内核栈大小
* `+0x018 Self             : Ptr32 _NT_TIB`：指向自身（_NT_TIB和_KPCR）
## 3.2. _KPCR的其它重要成员
* `+0x01c SelfPcr          : Ptr32 _KPCR`：指向自身（_KPCR）
* `+0x020 Prcb             : Ptr32 _KPRCB`：指针，指向_KPCR的PrcbData成员，方便日后修改拓展_KPCR结构体
* `+0x038 IDT              : Ptr32 _KIDTENTRY`：IDT表基址，每个CPU都有自己独立的IDT表
* `+0x03c GDT              : Ptr32 _KGDTENTRY`：GDT表基址，每个CPU都有自己独立的GDT表
* `+0x040 TSS              : Ptr32 _KTSS`：TSS任务段基址，每个CPU都有自己独立的TSS任务段
* `+0x051 Number           : UChar`：当前CPU编号
* `+0x120 PrcbData         : _KPRCB`：_KPCR的拓展结构体
## 3.3. +0x120 PrcbData（type _KPRCB）
* `+0x004 CurrentThread    : Ptr32 _KTHREAD`：CPU当前正在运行的线程
* `+0x008 NextThread       : Ptr32 _KTHREAD`：CPU下一个调度的线程
* `+0x00c IdleThread       : Ptr32 _KTHREAD`：如果没有其它线程可以调度时，CPU需要调度的线程
# 4. 等待链表和调度链表
## 4.1. 个链表：1个等待链表，32个调度链表
线程有三种状态：等待、就绪、运行。正在运行的线程存储在_KPCR中，就绪和等待线程则存储在另外的33个链表中，1个等待链表，32个就绪链表。这些链表都使用了_KTHREAD的0x060这个偏移，所以一个线程只能同时属于其中一个链表
## 4.2. 等待链表
所有等待状态的线程都存储在这个链表里面，比如说线程调用了Sleep或者WaitForSingleObject等函数时，就挂到这个链表里面
### 4.2.1. 等待链表头
Windbg命令`dd KiWaitListHead`可以查看等待链表头
## 4.3. 调度链表
总共有32个调度链表，分别对应线程优先级0-31，0最低，31最高，默认优先级一般是8，改变优先级就是脱链再挂链的过程。所有处于就绪状态的线程都存储在这些链表里面
### 4.3.1. 调度链表头
Windbg命令`dd KiDispatcherReadyListHead L70`可以查看调度链表头的数组，每个成员长度为8个字节，优先级依次为0-31
## 4.4. 版本差异
* WinXP中，无论有几个CPU，等待链表和调度链表只有一套，也就是1个等待链表+32个调度链表
* Win7中，无论有几个CPU，等待链表和调度链表只有一套，也就是1个等待链表+32个调度链表（64位中是64个调度链表）
* 服务器版本（比如Win2003）中，等待链表整个系统只有一套，但是调度链表是有几个CPU就有几套调度链表
# 线程切换
