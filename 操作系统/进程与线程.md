<!-- TOC -->

- [1. 进程相关结构体：_EPROCESS](#1-进程相关结构体_eprocess)
    - [1.1. +0x000 Pcb（type _KPROCESS）：线程调度相关](#11-0x000-pcbtype-_kprocess线程调度相关)
    - [1.2. _EPROCESS的其它重要成员](#12-_eprocess的其它重要成员)
- [2. 线程相关结构体：_ETHREAD](#2-线程相关结构体_ethread)
    - [2.1. +0x000 Tcb（type _KTHREAD）](#21-0x000-tcbtype-_kthread)
    - [2.2. _ETHREAD的其它重要成员](#22-_ethread的其它重要成员)
- [3. CPU相关结构体：_KPCR](#3-cpu相关结构体_kpcr)
    - [3.1. +0x000 NtTib（type _NT_TIB）](#31-0x000-nttibtype-_nt_tib)
    - [3.2. _KPCR的其它重要成员](#32-_kpcr的其它重要成员)
    - [3.3. +0x120 PrcbData（type _KPRCB）](#33-0x120-prcbdatatype-_kprcb)
- [4. 等待链表和调度链表](#4-等待链表和调度链表)
    - [4.1. 个链表：1个等待链表，32个调度链表](#41-个链表1个等待链表32个调度链表)
    - [4.2. 等待链表](#42-等待链表)
        - [4.2.1. 等待链表头](#421-等待链表头)
    - [4.3. 调度链表](#43-调度链表)
        - [4.3.1. 调度链表头](#431-调度链表头)
    - [4.4. 版本差异](#44-版本差异)
- [5. 线程切换](#5-线程切换)
    - [5.1. 线程切换原理](#51-线程切换原理)
    - [5.2. 当前线程调用API时的主动切换](#52-当前线程调用api时的主动切换)
    - [5.3. 时钟中断时的两种线程切换](#53-时钟中断时的两种线程切换)
        - [5.3.1. CPU时间片到期切换](#531-cpu时间片到期切换)
        - [5.3.2. 备用线程切换](#532-备用线程切换)
    - [5.4. 如何一直占据CPU](#54-如何一直占据cpu)
    - [5.5. Windows线程切换的核心函数：SwapContext](#55-windows线程切换的核心函数swapcontext)
    - [5.6. 线程切换与TSS](#56-线程切换与tss)
        - [5.6.1. 线程的内核堆栈](#561-线程的内核堆栈)
        - [5.6.2. TSS的作用](#562-tss的作用)

<!-- /TOC -->
# 1. 进程相关结构体：_EPROCESS
每个Windows进程在0环都有一个对应的结构体_EPROCESS，这个结构体包含了进程所有重要的信息
## 1.1. +0x000 Pcb（type _KPROCESS）：线程调度相关
* `+0x000 Header           : _DISPATCHER_HEADER`：标识_KPROCESS即进程为可等待对象（即可被WaitForSingleObject等函数等待的对象，如Mutex互斥体、Event事件等），所有可等待对象的第一个成员均为_DISPATCHER_HEADER结构体
* `+0x018 DirectoryTableBase : [2] Uint4B`：页目录表的基址
* `+0x020 LdtDescriptor    : _KGDTENTRY`：历史遗留问题，16位Windows段选择子不够，所以每个进程都有一个LDT表；32位Windows下该成员无意义
* `+0x028 Int21Descriptor  : _KIDTENTRY`：DOS下使用
* `+0x038 KernelTime       : Uint4B`：统计信息，统计进程在内核模式下所花的时间
* `+0x03c UserTime         : Uint4B`：统计信息，统计进程在用户模式下所花的时间
* `+0x050 ThreadListHead   : _LIST_ENTRY`：连接该进程所有线程的双向链表（总共存在两个这样的链表）的头，示意图见2.1节
* `+0x05c Affinity         : Uint4B`：规定进程里面的所有线程能够在哪个CPU上运行，比特位为1的下标号对应的CPU可以运行，比如4（100）代表可以在2号CPU上运行，如果此时只有一个或者两个CPU，该进程将会结束。所以32位最多32核，64位最多64核
* `+0x062 BasePriority     : Char`：基础优先级，该进程中所有线程最起码的优先级（即所有线程的优先级均会大于等于此优先级）
* `+0x063 ThreadQuantum    : Char`：调度相关，线程CPU时间片基础值
## 1.2. _EPROCESS的其它重要成员
* `+0x070 CreateTime       : _LARGE_INTEGER`：进程的创建时间
* `+0x078 ExitTime         : _LARGE_INTEGER`：进程的退出时间
* `+0x084 UniqueProcessId  : Ptr32 Void`：进程的编号即PID
* `+0x088 ActiveProcessLinks : _LIST_ENTRY`：连接所有活动进程的双向链表，全局变量PsActiveProcessHead指向链表头。利用PsActiveProcessHead加上该成员可以遍历所有进程，通过断链可以使得可以从WindowsAPI中隐藏进程，但是进程仍然可以正常运行（Windows的调度单元是线程，进程仅仅提供了一个运行环境如资源和物理页基址）
    * ![ActiveProcessLinks](../photo/操作系统_进程与线程_ActiveProcessLinks.jpg)
* `+0x090 QuotaUsage       : [3] Uint4B`：物理页相关统计信息
* `+0x09c QuotaPeak        : [3] Uint4B`：物理页相关统计信息
* `+0x0a8 CommitCharge     : Uint4B`：虚拟内存（物理页面以文件形式存储在硬盘中）相关统计信息
* `+0x0ac PeakVirtualSize  : Uint4B`：虚拟内存相关统计信息
* `+0x0b0 VirtualSize      : Uint4B`：虚拟内存相关统计信息
* `+0x0bc DebugPort        : Ptr32 Void`：调试端口，调试相关，该值为0的情况下无法通过正常手段来调试进程（可以通过其它手段）
* `+0x0c0 ExceptionPort    : Ptr32 Void`：异常端口，调试相关
* `+0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE`：句柄表，存有进程使用的各种其它内核的对象（事件、互斥体、文件等）的句柄（即地址）
* `+0x11c VadRoot          : Ptr32 Void`：标识用户地址空间使用情况
* `+0x174 ImageFileName    : [16] UChar`：进程镜像文件名，最多显示16个字节，多余字节将被截断
* `+0x190 ThreadListHead   : _LIST_ENTRY`：连接该进程所有线程的双向链表（总共存在两个这样的链表）的头，示意图见2.1节
* `+0x1a0 ActiveThreads    : Uint4B`：活动线程的数量，0代表无活动线程，进程即将结束，将会从活动进程链表中被移除
* `+0x1b0 Peb              : Ptr32 _PEB`：Process Environment Block，进程环境块，进程在3环的一个结构体（3环进程可以对其进行读写），里面包含了进程的模块列表、是否处于调试状态等重要信息

# 2. 线程相关结构体：_ETHREAD
每个Windows线程在0环都有一个对应的结构体_ETHREAD，这个结构体包含了线程所有重要的信息
## 2.1. +0x000 Tcb（type _KTHREAD）
* `+0x000 Header           : _DISPATCHER_HEADER`：标识_KTHREAD即线程为可等待对象
* `+0x018 InitialStack     : Ptr32 Void`：线程切换相关
* `+0x01c StackLimit       : Ptr32 Void`：线程切换相关
* `+0x020 Teb              : Ptr32 Void`：Thread Environment Block，线程环境块，大小4KB，线程在3环的一个结构体（3环进程可以对其进行读写），里面包含了线程的重要信息，在三环时fs:[0] -> teb，在0环时fs:[0] -> _kpcr
* `+0x028 KernelStack      : Ptr32 Void`：线程切换时存储栈顶指针
* `+0x02c DebugActive      : UChar`：调试相关，该值为-1的话不能使用调试寄存器Dr0-Dr7，3环进入0环时不会填充_kTrap_Frame中调试相关成员的值
* `+0x02d State            : UChar`：线程状态：就绪、等待、运行，仅仅用作记录，和线程的调度无关
* `+0x034 ApcState         : _KAPC_STATE`：APC相关
* `+0x060 WaitListEntry    : _LIST_ENTRY`：线程所属等待链表，线程调度相关
* `+0x060 SwapListEntry    : _SINGLE_LIST_ENTRY`：线程所属调度链表，线程调度相关，和线程所属等待链表占据同一个位置，也就是说线程只能同时属于其中一个链表
* `+0x06c BasePriority     : Char`：基础优先级，从所属进程继承而来（KPROCESS->BasePriority），但是可以通过KeSetBasePriorityThread函数重新设置
* `+0x06f Quantum          : Char`：调度相关，CPU时间片
* `+0x070 WaitBlock        : [4] _KWAIT_BLOCK`：指示线程等待的是哪个对象
* `+0x0e0 ServiceTable     : Ptr32 Void`：系统服务表基址
* `+0x0e8 ApcQueueLock     : Uint4B`：APC相关
* `+0x134 TrapFrame        : Ptr32 _KTRAP_FRAME`：用于进0环时保存环境
* `+0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE`：APC相关
* `+0x140 PreviousMode     : Char`：先前模式，用于某些内核函数判断程序是0环调用的还是3环调用的
* `+0x14c SavedApcState    : _KAPC_STATE`：APC相关
+0x06f Quantum          : Char
* `+0x1b0 ThreadListEntry  : _LIST_ENTRY`：连接一个进程所有线程的双向链表，总共存在两个这样的链表
    * ![ThreadListEntry](../photo/操作系统_进程与线程_ThreadListEntry.jpg)
## 2.2. _ETHREAD的其它重要成员
* `+0x1ec Cid              : _CLIENT_ID`：进程ID和线程ID
* `+0x220 ThreadsProcess   : Ptr32 _EPROCESS`：当前进程结构体的指针，可以定位进程
* `+0x22c ThreadListEntry  : _LIST_ENTRY`：连接一个进程所有线程的双向链表，总共存在两个这样的链表
# 3. CPU相关结构体：_KPCR
每个CPU在0环都有一个对应的结构体_KPCR，这个结构体包含了CPU本身要用的一些重要数据如GDT、IDT、线程相关信息
## 3.1. +0x000 NtTib（type _NT_TIB）
* `+0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD`：当前线程内核异常链表（SEH）
* `+0x004 StackBase        : Ptr32 Void`：当前线程内核栈基址
* `+0x008 StackLimit       : Ptr32 Void`：当前线程内核栈大小
* `+0x018 Self             : Ptr32 _NT_TIB`：指向自身（_NT_TIB和_KPCR）
## 3.2. _KPCR的其它重要成员
* `+0x01c SelfPcr          : Ptr32 _KPCR`：指向自身（_KPCR）
* `+0x020 Prcb             : Ptr32 _KPRCB`：指针，指向_KPCR的PrcbData成员，方便日后修改拓展_KPCR结构体
* `+0x038 IDT              : Ptr32 _KIDTENTRY`：IDT表基址，每个CPU都有自己独立的IDT表
* `+0x03c GDT              : Ptr32 _KGDTENTRY`：GDT表基址，每个CPU都有自己独立的GDT表
* `+0x040 TSS              : Ptr32 _KTSS`：TSS任务段基址，每个CPU都有自己独立的TSS任务段
* `+0x051 Number           : UChar`：当前CPU编号
* `+0x120 PrcbData         : _KPRCB`：_KPCR的拓展结构体
## 3.3. +0x120 PrcbData（type _KPRCB）
* `+0x004 CurrentThread    : Ptr32 _KTHREAD`：CPU当前正在运行的线程
* `+0x008 NextThread       : Ptr32 _KTHREAD`：CPU下一个调度的线程
* `+0x00c IdleThread       : Ptr32 _KTHREAD`：如果没有其它线程可以调度时，CPU需要调度的线程
* `+0x88c QuantumEnd       : Uint4B`：标志当前线程的CPU时间片是否用完，没用完的时候是0，用完的时候是非0值
# 4. 等待链表和调度链表
## 4.1. 个链表：1个等待链表，32个调度链表
线程有三种状态：等待、就绪、运行。正在运行的线程存储在_KPCR中，就绪和等待线程则存储在另外的33个链表中，1个等待链表，32个就绪链表。这些链表都使用了_KTHREAD的0x060这个偏移，所以一个线程只能同时属于其中一个链表
## 4.2. 等待链表
所有等待状态的线程都存储在这个链表里面，比如说线程调用了Sleep或者WaitForSingleObject等函数时，就挂到这个链表里面
### 4.2.1. 等待链表头
Windbg命令`dd KiWaitListHead`可以查看等待链表头
## 4.3. 调度链表
总共有32个调度链表，分别对应线程优先级0-31，0最低，31最高，默认优先级一般是8，改变优先级就是脱链再挂链的过程。所有处于就绪状态的线程都存储在这些链表里面
### 4.3.1. 调度链表头
Windbg命令`dd KiDispatcherReadyListHead L70`可以查看调度链表头的数组，每个成员长度为8个字节，优先级依次为0-31
## 4.4. 版本差异
* WinXP中，无论有几个CPU，等待链表和调度链表只有一套，也就是1个等待链表+32个调度链表
* Win7中，无论有几个CPU，等待链表和调度链表只有一套，也就是1个等待链表+32个调度链表（64位中是64个调度链表）
* 服务器版本（比如Win2003）中，等待链表整个系统只有一套，但是调度链表是有几个CPU就有几套调度链表
# 5. 线程切换
## 5.1. 线程切换原理
```c
#include "stdio.h"
#include <windows.h>

#define GMTHREADSTACKSIZE 0x80000     //定义线程栈的大小
#define MAXGMTHREAD 100   //支持的最大线程数

//线程信息结构体
typedef struct
{
	char* name;						//线程名
	int Flags;						//线程状态
	int SleepMillsecondDot;			//休眠时间

	void* initialStack;				//线程堆栈起始位置
	void* StackLimit;				//线程堆栈界限
	void* KernelStack;				//线程堆栈当前位置，也就是ESP

	void* lpParameter;				//线程函数的参数
	void(*func)(void* lpParameter);	//线程函数
}GMThread_t;

GMThread_t GMThreadList[MAXGMTHREAD] = { NULL, 0 };   //线程的列表
int CurrentThreadIndex = 0;  //当前线程的索引

//线程状态的标志
enum FLAGS
{
	GMTHREAD_CREATE = 0x1,
	GMTHREAD_READY = 0x2,
	GMTHREAD_SLEEP = 0x4,
	GMTHREAD_EXIT = 0x8,
};

//切换线程
__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp)
{
	__asm {
		//提升堆栈
		push ebp
			mov ebp, esp
			//保存现场
			push edi
			push esi
			push ebx
			push ecx
			push edx
			push eax
			//esi、edi指向
			mov esi, SrcGMThreadp
			mov edi, DstGMThreadp
			mov[esi + GMThread_t.KernelStack], esp;   把esp保存到kernelstack
			//经典线程切换，另外一个线程复活
			mov esp, [edi + GMThread_t.KernelStack]; 修改esp为目标线程的kernelstack

			pop eax
			pop edx
			pop ecx
			pop ebx
			pop esi
			pop edi
			pop ebp
			ret
	}
}

//调度
void Scheduling(void)
{
	int i;
	int TickCount;
	GMThread_t* SrcGMThreadp;
	GMThread_t* DstGMThreadp;
	TickCount = GetTickCount();     //获取当前tickcount
	SrcGMThreadp = &GMThreadList[CurrentThreadIndex];     //当前线程
	DstGMThreadp = &GMThreadList[0];    //目标线程暂时指向0

	for (i = 1; GMThreadList[i].name; i++) {     //遍历线程
		if (GMThreadList[i].Flags & GMTHREAD_SLEEP) {     //如果是休眠状态的线程
			if (TickCount > GMThreadList[i].SleepMillsecondDot) {       //如果当前tickcount大于唤醒时间，修改状态为就绪
				GMThreadList[i].Flags = GMTHREAD_READY;
			}
		}
		if (GMThreadList[i].Flags & GMTHREAD_READY) {      //如果是就绪状态的线程
			DstGMThreadp = &GMThreadList[i];        //修改目标线程指向就绪状态
			break;
		}
	}

	CurrentThreadIndex = DstGMThreadp - GMThreadList;    //获取目标线程索引（当前-0）
	SwitchContext(SrcGMThreadp, DstGMThreadp);      //切换线程
	return;
}

//启动线程的函数
void GMThreadStartup(GMThread_t* GMThreadp)
{
	GMThreadp->func(GMThreadp->lpParameter);    //调用线程函数，阻塞
	GMThreadp->Flags = GMTHREAD_EXIT;           //标志位修改为退出
	Scheduling();

	return;
}

//空闲线程的函数
void IdleGMThread(void* lpParameter)
{
	printf("IdleGMThread---------------\n");
	Scheduling();
	return;
}

//模拟压栈操作
void PushStack(unsigned int** Stackpp, unsigned int v)
{
	*Stackpp -= 1;
	**Stackpp = v;

	return;
}

//初始化线程
void initGMThread(GMThread_t* GMThreadp, char* name, void(*func)(void* lpParameter), void* lpParameter)
{
	unsigned char* StackPages;
	unsigned int* StackDWordParam;
	GMThreadp->Flags = GMTHREAD_CREATE;    //创建状态
	GMThreadp->name = name;
	GMThreadp->func = func;
	GMThreadp->lpParameter = lpParameter;
	StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE);   //申请一片栈空间
	ZeroMemory(StackPages, GMTHREADSTACKSIZE);    //初始化栈空间为0
	GMThreadp->initialStack = StackPages + GMTHREADSTACKSIZE;     //获取栈的初始位置
	StackDWordParam = (unsigned int*)GMThreadp->initialStack;     //获取栈指针
	//入栈
	PushStack(&StackDWordParam, (unsigned int)GMThreadp);         //压入结构体指针，充当启动线程的函数GMThreadStartup函数的参数
	PushStack(&StackDWordParam, (unsigned int)0);                 //压入0，充当启动线程的函数GMThreadStartup函数的返回地址
	PushStack(&StackDWordParam, (unsigned int)GMThreadStartup);   //压入启动线程的函数
	PushStack(&StackDWordParam, (unsigned int)5);                 //压入其它寄存器
	PushStack(&StackDWordParam, (unsigned int)7);
	PushStack(&StackDWordParam, (unsigned int)6);
	PushStack(&StackDWordParam, (unsigned int)3);
	PushStack(&StackDWordParam, (unsigned int)2);
	PushStack(&StackDWordParam, (unsigned int)1);
	PushStack(&StackDWordParam, (unsigned int)0);
	//当前线程的栈顶
	GMThreadp->KernelStack = StackDWordParam;
	GMThreadp->Flags = GMTHREAD_READY;          //就绪状态
	return;
}

//注册线程
int RegisterGMThread(char* name, void(*func)(void*lpParameter), void* lpParameter)
{
	int i;
	for (i = 1; GMThreadList[i].name; i++) {       //查找线程列表中是否有同名线程
		if (0 == _stricmp(GMThreadList[i].name, name)) {       //如果有同名线程，则定位到该线程，否则定位到下一个空位
			break;
		}
	}
	initGMThread(&GMThreadList[i], name, func, lpParameter);    //初始化线程

	return (i & 0x55AA0000);
}

//线程函数中调用的函数
void GMSleep(int MilliSeconds)
{
	GMThread_t* GMThreadp;
	GMThreadp = &GMThreadList[CurrentThreadIndex];    //获取当前线程结构体指针
	if (GMThreadp->Flags != 0) {         //处于正常状态
		GMThreadp->Flags = GMTHREAD_SLEEP;           //进入休眠状态
		GMThreadp->SleepMillsecondDot = GetTickCount() + MilliSeconds;      //设置唤醒时间
	}

	Scheduling();    //调度其它线程
	return;
}

void Thread1(void*) {
	while (1){
		printf("Thread11111111111111111111111111111111111111111111111111111\n");
		GMSleep(500);
	}
}
void Thread2(void*) {
	while (1) {
		printf("Thread2222222222222222222222222222222222\n");
		GMSleep(200);
	}
}

void Thread3(void*) {
	while (1) {
		printf("Thread3333333333333333333\n");
		GMSleep(10);
	}
}

void Thread4(void*) {
	while (1) {
		printf("Thread444\n");
		GMSleep(1000);
	}
}


int main()
{
	RegisterGMThread("Thread1", Thread1, NULL);
	RegisterGMThread("Thread2", Thread2, NULL);
	RegisterGMThread("Thread3", Thread3, NULL);
	RegisterGMThread("Thread4", Thread4, NULL);

	while (true) {
		Sleep(5);
		Scheduling();
	}

	return 0;
}
```
* 线程切换并不是有专门的线程根据时间片进行调度的，线程不是被动切换，而是主动切换（线程主动让出CPU）
* Windows和Linux切换线程并没有使用TSS来保存寄存器，而是使用堆栈
* 线程切换的过程本质上就是堆栈切换的过程
## 5.2. 当前线程调用API时的主动切换
Windows下实现SwitchContext函数功能（线程切换）的函数为kiSwapContext，Windows中的绝大多数API都会调用KiSwapContext函数导致线程切换，也就是说，只要调用Windows API，就会导致主动性质的线程切换，调用链为API函数->KiSwapThread->kiSwapContext->SwapContext
## 5.3. 时钟中断时的两种线程切换
Windows系列操作系统的时钟中断时间间隔是10-20ms（可以通过函数GetSystemTimeAdjustment来查看）
### 5.3.1. CPU时间片到期切换
当一个新的线程开始执行时，初始化程序会在_KTHREAD.Quantum赋给初始值，该值的大小由_KPROCESS.ThreadQuantum决定。每次时钟中断的时候会调用KeUpdateRunTime函数来更新当前线程的CPU时间片，该函数每次将当前线程的Quantum值减3，如果减到0，则将KPCR.PrcbData.QuantumEnd的值设置为非0。在时钟中断的最后，会调用KiDispatchInterrupt判断当前线程时间片是否到期即KPCR.PrcbData.QuantumEnd是否为0，如果到期了则调用KiQuantumEnd来重新设置时间片、找到要运行的线程，之后调用SwapContext来切换线程。
### 5.3.2. 备用线程切换
如果当前线程存在备用线程（KPCR.PrcbData.NextThread值不为空），即使CPU时间片没有到期，也会触发线程切换，判断代码位于KiDispatchInterrupt中，判断后调用SwapContext来切换线程
## 5.4. 如何一直占据CPU
如果一个线程不调用API，在代码中屏蔽时钟中断（CLI指令或者popfd来设置IF位为0，只能在0环设置），并且确保不会出现异常，那么当前线程将永久占有该CPU，所以说Windows是抢占式调度这种说法其实是错误的
## 5.5. Windows线程切换的核心函数：SwapContext
## 5.6. 线程切换与TSS
### 5.6.1. 线程的内核堆栈
每个线程都有一个内核堆栈，线程的内核堆栈通过_KTHREAD.InitialStack、_KTHREAD.KernelStack、_KTHREAD.StackLimit来界定。线程的内核堆栈的前0x210个字节存储的是浮点寄存器的值，之后是_Trap_Frame结构体。线程调用API进入0环时，中断门调用通过TSS.ESP0得到0环堆栈，快速调用通过MSR获取一个临时0环堆栈，之后仍然会通过TSS.ESP0获取真正的0环堆栈
### 5.6.2. TSS的作用
intel设计TSS就是为了线程切换，但是Windows和Linux均未采用，而是采用堆栈保存寄存器。TSS对于线程切换三个作用：
* 切换线程后，保存当前线程堆栈至esp0，用于之后线程进入0环的时候获取0环堆栈
* 获取新线程页目录表基址，填充到TSS，并切换至cr3寄存器
* 获取新线程IO权限位图（_KTHREAD.Iopl），填充到TSS->I/O Map Base Address