<!-- TOC -->

- [1. 并发与同步](#1-并发与同步)
- [2. 临界区](#2-临界区)
    - [2.1. 代码安全](#21-代码安全)
    - [2.2. 保护代码安全：LOCK前缀](#22-保护代码安全lock前缀)
    - [2.3. 保护多行代码安全：临界区](#23-保护多行代码安全临界区)
        - [2.3.1. 临界区方案：C语言实现方案](#231-临界区方案c语言实现方案)
        - [2.3.2. 临界区方案：汇编实现方案](#232-临界区方案汇编实现方案)
- [3. 自旋锁](#3-自旋锁)
    - [3.1. 不同情况下的内核文件](#31-不同情况下的内核文件)
    - [3.2. 自旋](#32-自旋)
    - [3.3. 自旋锁的特点](#33-自旋锁的特点)
- [4. 线程的等待与唤醒](#4-线程的等待与唤醒)
    - [4.1. 临界区与自旋锁的局限性](#41-临界区与自旋锁的局限性)
    - [4.2. 可等待对象](#42-可等待对象)
    - [4.3. 线程与可等待对象之间的联系：等待网](#43-线程与可等待对象之间的联系等待网)
        - [4.3.1. 等待块](#431-等待块)
        - [4.3.2. 等待网的结构](#432-等待网的结构)
    - [4.4. 线程等待与唤醒机制的核心：WaitForSingleObject](#44-线程等待与唤醒机制的核心waitforsingleobject)

<!-- /TOC -->
# 1. 并发与同步
* 并发是指多个线程在同时执行
    * 单核（本质上是分时执行，不是真正意义上的同时执行）
    * 多核（在某一时刻，会有多个线程同时执行）
* 同步是指保证在并发执行的环境中，各个线程可以有序的执行（即保证并发代码执行安全）。如果线程中只对局部变量进行操作，由于每个线程拥有自己的堆栈，那么便不会产生同步问题。只有当线程对全局变量进行操作时，才会出现同步问题。
# 2. 临界区
## 2.1. 代码安全
* `dwVal++;`，这种C代码是不安全的
* `INC DWORD PTR DS:[0x12345678]`，这种汇编代码在单核情况下安全，在多核情况下不安全
## 2.2. 保护代码安全：LOCK前缀
`LOCK INC DWORD PTR DS:[0x12345678]`，这种汇编代码是安全的，LOCK前缀会锁住内存，保证同一时刻只能有一个核对该内存进行操作。Windows提供的一些原子操作相关的API就是利用了这个前缀,如InterlockedIncrement、InterlockedDecrement、InterlockedExchange、InterlockedCompareExchange、InterlockedExchangeAdd、InterlockedFlushSList、InterlockedPopEntrySList、InterlockedPushEntrySList，这些函数位于kernel32.dll或者ntdll.dll。但是LOCK指令对于线程需要执行多行汇编代码的情况显得力不从心。
## 2.3. 保护多行代码安全：临界区
临界区是指一次只允许一个线程进入直到离开，实现临界区的方式就是加锁，就是设置一个全局变量，进入加一，出去减一。
### 2.3.1. 临界区方案：C语言实现方案
`if(dwFlag == 0){dwFlag=1;......dwFlag=0;}`，这种实现方案也不安全。
### 2.3.2. 临界区方案：汇编实现方案
```x86asm
Flag = 0
Lab:       ;进入临界区代码
    mov eax,1
    lock xadd [Flag],eax
    cmp eax,0
    jz Fun       ;Flag为0，跳转实现功能代码
    dec [Flag]   ;Flag为1，无法进入临界区，还原Flag，线程进入等待状态
Sleep:
    ;让线程Sleep，进入等待状态
Fun:
    ......
    ret
Leave:     ;离开临界区代码
    lock dec [Flag]
```
以上代码在单核、多核情况下均安全。如果去掉两个lock前缀，则单核安全，多核不安全。
# 3. 自旋锁
## 3.1. 不同情况下的内核文件
Windows启动时，根据CPU核心数为单核、多核的不同，内核文件中的代码也不相同。自旋锁相关的函数，名字里会带有`SpinLock`字样，如KeAcquireSpinLockAtDpcLevel。在多核的内核文件中，这些函数有功能代码即有实际意义，而单核的内核文件中，函数直接返回，没有任何意义。
## 3.2. 自旋
自旋锁在无法上锁的情况下，不会选择让线程休眠（因为线程休眠会导致线程切换，很耗费资源），而是利用`pause`指令让CPU空转一会儿，然后再次尝试上锁，进入循环，所以称作自旋锁。
## 3.3. 自旋锁的特点
* 自旋锁只有在多核条件下才有价值，因为在单核情况下，自旋会使得别的线程得不到执行，自然也不会释放资源，自旋将是一个死循环
* 自旋锁与临界区、事件、互斥体一样，都是一种同步机制，可以让线程处于等待状态，区别在于自旋锁不用切换线程，其他的同步机制都需要切换线程
# 4. 线程的等待与唤醒
## 4.1. 临界区与自旋锁的局限性
* 临界区：Sleep函数的休眠时间长度不好确定
* 自旋锁：自旋锁只有在多核的情况下才有意义，而且只有在等待时间很短的情况下才有意义，如果等待时间较长，CPU空转对资源是种极大的浪费
## 4.2. 可等待对象
在Windows中，一个线程可以通过等待一个或多个可等待对象，从而进入等待状态，另一个线程可以在某些时刻调用相关函数（等待对象不同，调用的相关函数也不同）来唤醒等待这些对象的其它线程。等待函数包括WaitForSingleObj、WaitForMultipleObjects、Sleep等，唤醒函数包括SetEvent、ReleaseSemaphore、ReleaseMutant等。可等待对象包括进程（dt_KPROCESS）、线程（dt_KTHREAD）、定时器（dt_KTIMER，Sleep函数对应的可等待对象）、信号量（dt_KSEMAPHORE）、事件（dt_KEVENT）、互斥体（dt_KMUTANT）、文件（dt_FILE_OBJECT）等，可等待对象的结构体都包含有_DISPATCHER_HEADER对象（大部分情况下_DISPATCHER_HEADER为可等待对象的第一个成员），所有包含有_DISPATCHER_HEADER对象的对象，都是可等待对象。
## 4.3. 线程与可等待对象之间的联系：等待网
### 4.3.1. 等待块
等待块即结构体_KWAIT_BLOCK，每个等待块记录了一个线程和一个可等待对象之间的联系。而一个线程可以等待多个可等待对象，一个可等待对象也可以被多个线程等待。这些等待块之间会互相连接，最后形成一个等待网。
### 4.3.2. 等待网的结构
![WaitNet](../photo/操作系统_并发与同步_WaitNet.jpg)
* 线程中的KTHREAD.WaitBlockList指向了等待块列表，这是一个单向循环链表，由_KWAIT_BLOCK.NextWaitBlock链接，链接了该线程等待的所有可等待对象的等待块。
* 可等待对象中的_DISPATCHER_HEADER.WaitListHead作为链表头指向了等待块列表，这是一个双向循环链表，由WaitListEntry链接，链接了所有等待该可等待对象的线程的等待块。
* 以上两个链表加上所有处于等待状态中的线程、所有被等待的可等待对象，形成了一个等待网。在等待网上，可以通过线程找到相关可等待对象，也可以通过可等待对象找到相关线程。
## 4.4. 线程等待与唤醒机制的核心：WaitForSingleObject
这个函数会调用内核函数NtWaitForSingleObject来根据3环用户提供的句柄，找到等待对象的内核地址，之后找到结构体中的_DISPATCHER_HEADER对象指针，将其作为参数传给KeWaitForSingleObject，实现核心功能。