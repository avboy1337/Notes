1、静态分析
1）反病毒引擎扫描、沙箱运行
2）计算哈希值，查找标签和情报
3）字符串、检查加壳与混淆（有些PEiD插件会静默运行可执行文件！！！）
4）导入表、导出表、节（Depend可以查找根据序号导入的函数）
5）配置虚拟机环境（用虚拟网络环境！仅主机模式可能主机会被攻击！虚拟机的记录重放功能了解一下）
6）可以通过rundll和修改PE头的方式来运行dll文件

# 调用约定
* cdecl，参数从右往左入栈，调用者清理栈，返回值位于EAX，C语言的标准调用约定
* stdcall，参数从右往左入栈，被调用者清理栈，返回值位于EAX，这个是Windows API的标准调用约定
* fastcall，先用EDX、ECX，再用栈传递参数，被调用者清理栈，返回值位于EAX
* C++调用约定 使用this指针
* VC提供了 thiscall调用， 将this 传递给ecx
* gc++中被当做静态变量，存放在栈顶

5、特殊文件
1）\\?\前缀告诉操作系统禁用字符串解析
2）\\ServerName\share和\\?\serverName\share开头的文件为共享文件
3）\\.\开头的文件为Win32设备名字空间，可以直接访问物理设备（Windows2003之后只能从Ring0访问）
4）备用数据流（ADS）允许附加数据添加到一个已存在的NTFS文件中，这个数据只有在访问流时才会可见，命名为normalFile.txt:Stream:$DATA

6、Tips
2、进程中每个线程共享内存空间，但是拥有自己的寄存器、CPU、栈
4、Windows服务通常以WIN32_SHARE_PROCESS类型运行，这种类型将这个服务的代码保存到一个DLL中，并在一个进程中组合多个不同的服务，进程中表现为svchost.exe。而WIN32_OWN_PROCESS类型在一个exe文件中保存代码，并且作为一个独立进程运行。KERNEL_DRIVER则被用来加载代码到内核中执行。
5、组件对象模型（COM）是一个接口标准，使用COM的线程必须在调用任何其它COM函数之前，至少一次调用OleInitialize或CoInitializeEx函数，COM对象通过全局唯一标识符（GUID=CLSID+IID）访问
8、原生API，参数粒度更细，提供信息更多，可以绕过普通API，NtContinue被用来从一个异常处理返回主线程，返回的位置可以被指定
9、PE头的子系统指明了一个程序是不是原生应用程序
10、设置DR7寄存器中的通用探测标志位，任何通过mov指令访问调试寄存器的操作都会触发中断（别的指令不会触发）
11、调试器可能两次处理同一异常，调试器第一次捕获异常后将其传递给程序，程序无法处理时，会再次转给调试器，如果调试器不处理，程序就会崩溃
12、调试器会对INT3异常进行特殊处理，操作系统则不会

7、恶意代码行为
1）下载器、启动器
2）后门、反弹shell、远控（可发动旁路劫持攻击）、僵尸网络（相比于远控，量大、操作行为相同、进行大规模而非针对性攻击）
3）窃取登录凭证（转储Windows口令哈希来离线破解或者发动Pass-the-hash攻击、GINA即第三方自定义登录方式拦截）
4）键盘记录器（内核Rootkit捕获、挂钩、轮询（使用函数GetAsyncKeyState判断一个按键是按下或者弹起，使用GetForegroundWindow识别当前聚焦的前端窗口））