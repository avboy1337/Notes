<!-- TOC -->

- [1. 调用约定](#1-调用约定)
- [2. 其它](#2-其它)

<!-- /TOC -->
# 1. 调用约定
* cdecl，参数从右往左入栈，调用者清理栈，返回值位于EAX，C语言的标准调用约定
* stdcall，参数从右往左入栈，被调用者清理栈，返回值位于EAX，这个是Windows API的标准调用约定
* fastcall，先用EDX、ECX，再用栈传递参数，被调用者清理栈，返回值位于EAX
* C++调用约定 使用this指针
* VC提供了 thiscall调用， 将this 传递给ecx
* gc++中被当做静态变量，存放在栈顶
# 2. 其它
* `\\?\`前缀告诉操作系统禁用字符串解析
* `\\ServerName\share`和`\\?\serverName\share`开头的文件为共享文件
* `\\.\`开头的文件为Win32设备名字空间，可以直接访问物理设备（Windows2003之后只能从Ring0访问）
* 备用数据流（ADS）允许附加数据添加到一个已存在的NTFS文件中，这个数据只有在访问流时才会可见，命名为normalFile.txt:Stream:$DATA
* 进程中每个线程共享内存空间，但是拥有自己的寄存器、CPU、栈
* 组件对象模型（COM）是一个接口标准，使用COM的线程必须在调用任何其它COM函数之前，至少一次调用OleInitialize或CoInitializeEx函数，COM对象通过全局唯一标识符（GUID=CLSID+IID）访问
* 原生API，参数粒度更细，提供信息更多，可以绕过普通API，NtContinue被用来从一个异常处理返回主线程，返回的位置可以被指定
* PE头的子系统指明了一个程序是不是原生应用程序
* 设置DR7寄存器中的通用探测标志位，任何通过mov指令访问调试寄存器的操作都会触发中断（别的指令不会触发）
* 调试器可能两次处理同一异常，调试器第一次捕获异常后将其传递给程序，程序无法处理时，会再次转给调试器，如果调试器不处理，程序就会崩溃
* 调试器会对INT3异常进行特殊处理，操作系统则不会
* 可以通过rundll和修改PE头的方式来运行dll文件